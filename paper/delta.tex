\section{\tDelta Protocol}
\label{sec:tdelta-protocol}

A straightforward solution to preventing dirty writes is for transactions to take long duration write locks \cite{Berenson1995}, releasing them only once the acquiring transaction has committed or aborted. To prevent deadlock a policy such as \texttt{NO_WAIT} deadlock detection is used, which was shown to be the optimal policy in a distributed, partitioned database \cite{Harding2017}.

Our \tDelta protocol employs principles behind all these well-tested strategies but has two crucial differences:
\begin{itemize}
\item No locks are used.
\item A write operation need not await until the preceding write commits but can proceed if at least $\Delta$ duration (measured in local clock) has elapsed.
\end{itemize}

These differences lead to several advantages in the context of graph databases. Firstly, a subset of edges are traversed and modified with a high frequency e.g. critical sections of motorway in a road network, leading to high contention. Secondly, graph transactions tend to be longer-lived than transactions in relational databases. Waiting for earlier writes on edges by long running transactions to commit, these frequently accessed edges significantly limit concurrency and reduce throughput. With these concerns in mind we developed the \tDelta protocol, which aimed at preventing edges becoming half-corrupted and hence quashing the seed of corruption whilst keeping performance at an acceptable level.\footnote{The \tDelta protocol is solely a concurrency control mechanism for distributed edges, guarantees about vertices, local edges are beyond the scope of this paper.}

\subsection{Protocol Description}
\label{sec:protocol-description}

The \tDelta Protocol has five rules:
\begin{enumerate}
\item A transaction's update on an end pointer of an edge is initially tentative which would become permanent only if that transaction is permitted to commit.
\item A tentative write is possible if the end pointer is either in a permanent state or the immediately preceding tentative update was done at least $\Delta$ time before (where time is measured as per local clock).
\item If a transaction successfully performs all its tentative updates, then it is permitted to commit; otherwise, it must abort.
\item A transaction commits, when all its tentative updates are made permanent, e.g., using an atomic commitment protocol.
\item Tentative updates of an aborting transactions are ignored. An ignored tentative update can make a new transaction abort for up to $\Delta$ time after it was created; it is harmless thereafter and can be garbage collected at any time.
\end{enumerate}

\subsection{Correctness Reasoning}
\label{sec:corr-reas}

Let us define $\delta$ as the bound estimate on the interval that may elapse between a transaction updating one end of a distributed edge at one server and updating the other end of the same edge at another server.

Let $\Delta$ be chosen such that $\Delta > \delta$. Now consider the interleaving in Figure \ref{fig:tx-ty} and let $t_x$ be the (global) time when $T_x$ starts at server $S_i$; similarly $t_y$ be the time $T_y$ starts at server $S_j$. Note $t_y < t_x$, i.e. $(t_x - t_y) > 0$.

Say, $T_y$ reaches $S_i$ at time $t_y + d$, where $d$ is the actual time elapsed between completing a tentative write at one end and starting at another end, let us assume that $d \leq \delta$. When $T_y$ arrives at $S_i$ it will find a tentative write done at time $t_x$. In this case, $t_y + d - t_x = d - (t_x-t_y) < d \leq \delta < \Delta$; so, $T_y$ will abort, preventing writes from interleaving and half-corrupting the edge. A similar arguments can be made for the scenario in with Figure \ref{fig:ty-tx}. For the interleaving in Figure \ref{fig:same-side}, if $t_y - t_x > \Delta$, then $T_y$ cannot overtake $T_x$ at $S_j$.

Assume that $d > \Delta$, i.e., the estimate $\delta$ does not hold at this moment. In Figure \ref{fig:tx-ty} interfering updates are avoided only if $t_y + d - t_x = d - (t_x-t_y) < d \leq \delta < \Delta$ otherwise, an edge becomes half-corrupted. This holds for the interleaving in \ref{fig:ty-tx}. Thus, in the extreme case $t_x = t_y$, reciprocal consistency is not guaranteed if $d > \Delta$ when the former exceeds its upper bound estimate $\delta$. For Figure \ref{fig:same-side}, if $d$ for $T_x$ is larger than $\Delta$, reciprocal consistency can be violated.

This protocol is strictly weaker than Read Uncommitted isolation, ensuring only writes to distributed edge are totally ordered, preserving reciprocal consistency. The benefit of this approach is reduced contention on frequently accessed distributed edges, as the time a transaction has exclusive access to a given distributed edge is decreased.

In summary, the \tDelta protocol attempts to prevent the occurrence of half-corrupted distributed edges by aborting transactions but if $\Delta$ is exceeded edge can become half-corrupted and process of corruption described in Section \ref{sec:db-corruption} can still occur. Two questions naturally arise regards the performance of the protocol. For different values of $\Delta$:
\begin{itemize}
\item Given distributed edges can still become half-corrupted if $\Delta$ is exceeded, by how much time does the protocol increase the time until operational corruption?
\item How many transactions are aborted as a result of the protocol?
\end{itemize}


%The two paragraphs (The protocol leverages... edge is lost) can be commented out.

%Figures 5 and 6 can be removed.

% The protocol leverages the fact that a transaction that writes at one end of a distributed edge, must then immediately write the other end. It is then assumed that the network delay between two servers can be predicted to be some $\Delta$. All writes are temporary and assumed to be made permanent by a later atomic commitment protocol once the transaction has completed. From this, a distributed edge write is allowed to proceed provided there is no other temporary write preceding it within $\Delta$; measured as per the local clock time. Figure \ref{delta-abort} shows an instance of the protocol preventing the interleaving in Figure \ref{conf-scen} (c), $T_x$ overtakes $T_y$ but is aborted when arriving at $S_j$ as $T_y$ has already wrote tentatively within $\Delta$. An aborted transaction, aborts any and every previous tentative write that it may have successfully completed. This protocol avoids all conflict scenarios in Figure \ref{conf-scen} provided $\Delta$ is not exceeded.



% \begin{figure}[H]
%   \centering
%   \begin{tikzpicture}[node distance=2cm]
%     % s1
%     \draw [thick] (1.3,3) -- (1.7,3);
%     \draw [thick,<-,>=stealth] (1.5,0) -- (1.5,3) node[anchor=south] {$S_i$};
%     % s2
%     \draw [thick] (3.3,3) -- (3.7,3);
%     \draw [thick,<-,>=stealth] (3.5,0) -- (3.5,3) node[anchor=south] {$S_j$};

%     \draw [thick,->,>=stealth] (1.5,2.5) node[left] {$T_x$} -- (3.5,0.5);
%     \draw [thick,->,>=stealth] (1.5,2) node[left] {$T_y$} -- (3.5,1.8);

%     \draw [thick,<->,>=stealth] (3.7,0.5) -- (3.7,1.8) node[midway,right] {$< \Delta$};

%   \end{tikzpicture}
%   \caption{An example of the \tDelta protocol preserving reciprocal consistency.}
%   \label{delta-abort}
% \end{figure}

% Correctly choosing $\Delta$ is paramount, as if it is exceeded all three conflict scenarios can still occur, resulting in half-corrupted edges and the spread of semantic corruption. Figure \ref{corruption-again} displays an example when the \tDelta protocol fails to maintain reciprocal consistency. The network delay between $S_i$ and $S_j$ is sufficiently large the total ordering of writes to the distributed edge is lost.

% \begin{figure}[H]
%   \centering
%   \begin{tikzpicture}[node distance=2cm]
%     \draw [thick] (1.3,3) -- (1.7,3);
%     \draw [thick,<-,>=stealth] (1.5,0) -- (1.5,3) node[anchor=south] {$S_i$};
%     \draw [thick] (3.3,3) -- (3.7,3);
%     \draw [thick,<-,>=stealth] (3.5,0) -- (3.5,3) node[anchor=south] {$S_j$};
%         \draw [thick,->,>=stealth] (1.5,2.7) node[left] {$T_x$} -- (3.5,0.8);
%     \draw [thick,<-,>=stealth] (1.5,1) -- (3.5,2.2)  node[right] {$T_y$};

%     \draw [thick,<->,>=stealth] (4.2,1) -- (4.2,2.2) node[midway,left] {$> \Delta$};
%     \draw [thick,<->,>=stealth] (0.8,1) -- (0.8,2.5) node[midway,right] {$> \Delta$};
%   \end{tikzpicture}
%   \caption{An example of the \tDelta protocol failing to preserve reciprocal consistency.}
%   \label{corruption-again}
% \end{figure}
