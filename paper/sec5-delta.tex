\section{\tDelta Protocol}
\label{sec:tdelta-protocol}

A straightforward solution to preventing dirty writes is for transactions to take long duration write locks \cite{Berenson1995}, releasing them only once the acquiring transaction has committed or aborted. To prevent deadlock a policy such as \texttt{NO_WAIT} deadlock detection is used, which was shown to be the optimal policy in a distributed, partitioned database \cite{Harding2017}.

Our \tDelta protocol employs principles behind all these well-tested strategies but has two crucial differences:
\begin{itemize}
\item No locks are used.
\item A write operation need not await until the preceding write commits but can proceed if at least $\Delta$ duration (measured in local clock) has elapsed.
\end{itemize}

These differences lead to several advantages in the context of graph databases. Firstly, a subset of edges are traversed and modified with a high frequency e.g. critical sections of motorway in a road network, leading to high contention. Secondly, graph transactions tend to be longer-lived than transactions in relational databases. Waiting for earlier writes on edges by long running transactions to commit, these frequently accessed edges significantly limit concurrency and reduce throughput. With these concerns in mind we developed the \tDelta protocol, which aimed at preventing edges becoming half-corrupted and hence quashing the seed of corruption whilst keeping performance at an acceptable level.\footnote{The \tDelta protocol is solely a concurrency control mechanism for distributed edges, guarantees about vertices, local edges are beyond the scope of this paper.}

\subsection{Protocol Description}
\label{sec:protocol-description}

The \tDelta Protocol has five rules:
\begin{enumerate}
\item A transaction's write on an end pointer of an edge is initially tentative which would become permanent only if that transaction is permitted to commit.
\item A tentative write is possible if the end pointer is either in a permanent state or the immediately preceding tentative write was done at least $\Delta$ time before (where time is measured as per local clock).
\item If a transaction successfully performs all its tentative writes, then it is permitted to commit; otherwise, it must abort.
\item A transaction commits, when all its tentative writes are made permanent, e.g., using an atomic commitment protocol.
\item Tentative writes of an aborting transactions are ignored. An ignored tentative write can make a new transaction abort for up to $\Delta$ time after it was created; it is harmless thereafter and can be garbage collected at any time.
\end{enumerate}

\subsection{Correctness Reasoning}
\label{sec:corr-reas}

Let us define $\delta$ as the bound estimate on the interval that may elapse between a transaction writing one end of a distributed edge at one server and writing the other end of the same edge at another server.

Let $\Delta$ be chosen such that $\Delta > \delta$.
Now consider the interleaving in Figure \ref{fig:b} and let $t_x$ be the (global) time when $T_x$ starts at server $S_i$; similarly $t_y$ be the time $T_y$ starts at server $S_j$.
Note $t_y < t_x$, i.e. $(t_x - t_y) > 0$.

Say, $T_y$ reaches $S_i$ at time $t_y + d$, where $d$ is the actual time elapsed between completing a tentative write at one end and starting at another end, let us assume that $d \leq \delta$.
When $T_y$ arrives at $S_i$ it will find a tentative write done at time $t_x$.
In this case, $t_y + d - t_x = d - (t_x-t_y) < d \leq \delta < \Delta$; so, $T_y$ will abort, preventing writes from interleaving and half-corrupting the edge.
A similar arguments can be made for the scenario in with Figure \ref{fig:b}, where $t_y > t_x$ and $T_x$ will abort because it will find out, on reaching server $S_j$ for the final tentative write, that $t_x +d - t_y = d - (t_y-t_x) < d <= \delta < \Delta$.
For the interleaving in Figure \ref{fig:same-side}, if $t_y - t_x > \Delta$, then $T_y$ cannot overtake $T_x$ at $S_j$.

Assume that $d > \delta$, i.e., the estimate $\delta$ does not hold at this moment.
In Figure \ref{fig:b} interfering writes are avoided only if $t_y + d - t_x = d - (t_x-t_y) < d < \Delta$ otherwise, reciprocal inconsistency occurs.
In Figure \ref{fig:a} interfering writes are avoided only if $t_x + d - t_y = d - (t_y-t_x) < d < \Delta$ otherwise, reciprocal inconsistency occurs.
Thus, in the extreme case $t_x = t_y$ and reciprocal consistency is not guaranteed if $\Delta < d$ when the latter exceeds its upper bound estimate $\delta$.
For Figure \ref{fig:c}, interfering writes are avoided only if $(t_y + d) - (t_x + d) = (t_y- t_x) < d < \Delta$ other reciprocal inconsistency occurs.

% This protocol is strictly weaker than Read Uncommitted isolation, ensuring only writes to distributed edge are totally ordered, preserving reciprocal consistency. The benefit of this approach is reduced contention on frequently accessed distributed edges, as the time a transaction has exclusive access to a given distributed edge is decreased.

% In summary, the \tDelta protocol attempts to prevent the occurrence of half-corrupted distributed edges by aborting transactions but if $\Delta$ is exceeded edge can become half-corrupted and process of corruption described in Section \ref{sec:db-corruption} can still occur. Two questions naturally arise regards the performance of the protocol. For different values of $\Delta$:
% \begin{itemize}
% \item Given distributed edges can still become half-corrupted if $\Delta$ is exceeded, by how much time does the protocol increase the time until operational corruption?
% \item How many transactions are aborted as a result of the protocol?
% \end{itemize}


In summary, the \tDelta protocol eliminates interleaving of transactions during edge writes, so long as $\Delta$ remains larger than the interval $d$ that elapses between a transaction completing its write at one end of a distributed edge and starting at the other end.
Since the exact value of $d$ taken by a transaction cannot be precisely known in advance, its bound $\delta$ is estimated with the best effort and we choose $\Delta > \delta$.

The larger the value of $\Delta$ used, the more likely is that $\Delta > d$ holds and half-corruption and thereby operational corruption are averted; also, the more likely is that one or more of concurrent transactions will find their tentative write within $\Delta$ time of each other and choose to abort.
Our performance evaluation of the protocol will therefore involve measuring the folowing two metrics for various values of $\Delta$:
\begin{itemize}
\item Time taken for 10\% of a large database to be corrupted due to the introduction of half-corruption, and
\item Number of transactions being aborted per second.
\end{itemize}
e let $d$ be an exponentially distributed random variable with mean $\mu$, $D\sim \exp(\mu)$. Therefore, the probability of $d$ exceeding $\Delta$ is given by $P(D > \Delta) = e^{(-\mu \Delta)}$.

%The two paragraphs (The protocol leverages... edge is lost) can be commented out.

%Figures 5 and 6 can be removed.

% The protocol leverages the fact that a transaction that writes at one end of a distributed edge, must then immediately write the other end. It is then assumed that the network delay between two servers can be predicted to be some $\Delta$. All writes are temporary and assumed to be made permanent by a later atomic commitment protocol once the transaction has completed. From this, a distributed edge write is allowed to proceed provided there is no other temporary write preceding it within $\Delta$; measured as per the local clock time. Figure \ref{delta-abort} shows an instance of the protocol preventing the interleaving in Figure \ref{conf-scen} (c), $T_x$ overtakes $T_y$ but is aborted when arriving at $S_j$ as $T_y$ has already wrote tentatively within $\Delta$. An aborted transaction, aborts any and every previous tentative write that it may have successfully completed. This protocol avoids all conflict scenarios in Figure \ref{conf-scen} provided $\Delta$ is not exceeded.



% \begin{figure}[H]
%   \centering
%   \begin{tikzpicture}[node distance=2cm]
%     % s1
%     \draw [thick] (1.3,3) -- (1.7,3);
%     \draw [thick,<-,>=stealth] (1.5,0) -- (1.5,3) node[anchor=south] {$S_i$};
%     % s2
%     \draw [thick] (3.3,3) -- (3.7,3);
%     \draw [thick,<-,>=stealth] (3.5,0) -- (3.5,3) node[anchor=south] {$S_j$};

%     \draw [thick,->,>=stealth] (1.5,2.5) node[left] {$T_x$} -- (3.5,0.5);
%     \draw [thick,->,>=stealth] (1.5,2) node[left] {$T_y$} -- (3.5,1.8);

%     \draw [thick,<->,>=stealth] (3.7,0.5) -- (3.7,1.8) node[midway,right] {$< \Delta$};

%   \end{tikzpicture}
%   \caption{An example of the \tDelta protocol preserving reciprocal consistency.}
%   \label{delta-abort}
% \end{figure}

% Correctly choosing $\Delta$ is paramount, as if it is exceeded all three conflict scenarios can still occur, resulting in half-corrupted edges and the spread of semantic corruption. Figure \ref{corruption-again} displays an example when the \tDelta protocol fails to maintain reciprocal consistency. The network delay between $S_i$ and $S_j$ is sufficiently large the total ordering of writes to the distributed edge is lost.

% \begin{figure}[H]
%   \centering
%   \begin{tikzpicture}[node distance=2cm]
%     \draw [thick] (1.3,3) -- (1.7,3);
%     \draw [thick,<-,>=stealth] (1.5,0) -- (1.5,3) node[anchor=south] {$S_i$};
%     \draw [thick] (3.3,3) -- (3.7,3);
%     \draw [thick,<-,>=stealth] (3.5,0) -- (3.5,3) node[anchor=south] {$S_j$};
%         \draw [thick,->,>=stealth] (1.5,2.7) node[left] {$T_x$} -- (3.5,0.8);
%     \draw [thick,<-,>=stealth] (1.5,1) -- (3.5,2.2)  node[right] {$T_y$};

%     \draw [thick,<->,>=stealth] (4.2,1) -- (4.2,2.2) node[midway,left] {$> \Delta$};
%     \draw [thick,<->,>=stealth] (0.8,1) -- (0.8,2.5) node[midway,right] {$> \Delta$};
%   \end{tikzpicture}
%   \caption{An example of the \tDelta protocol failing to preserve reciprocal consistency.}
%   \label{corruption-again}
% \end{figure}
